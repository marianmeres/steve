# LLM Context: @marianmeres/steve

## QUICK REFERENCE

- Package: @marianmeres/steve
- Version: 1.9.1
- Purpose: PostgreSQL-based job queue and processing system
- Platforms: Deno (native), Node.js (via npm build)
- License: MIT
- Repository: https://github.com/marianmeres/steve

## PACKAGE OVERVIEW

Steve is a production-ready PostgreSQL job queue manager for TypeScript/JavaScript. It handles asynchronous job execution with retry logic, scheduling, timeout handling, and database health monitoring.

Core capabilities:
- Concurrent job processing with multiple workers
- Job scheduling (future execution via run_at)
- Configurable retry with exponential backoff
- Per-attempt timeout enforcement
- Database resilience (auto-retry on transient failures)
- Health monitoring with callbacks
- Event subscriptions (onDone, onAttempt)
- Graceful shutdown handling

## ARCHITECTURE

```
src/
├── mod.ts                    # Public API exports
└── steve/
    ├── jobs.ts               # Main Jobs class (entry point)
    ├── job/                  # Job operations (private modules)
    │   ├── _claim-next.ts    # Atomic job claiming (FOR UPDATE SKIP LOCKED)
    │   ├── _create.ts        # Job creation
    │   ├── _execute.ts       # Job execution orchestration
    │   ├── _find.ts          # Job retrieval
    │   ├── _handle-failure.ts # Failure + retry scheduling
    │   ├── _handle-success.ts # Success handling
    │   ├── _log-attempt.ts   # Attempt logging
    │   ├── _mark-expired.ts  # Expired job cleanup
    │   ├── _health-preview.ts # Statistics collection
    │   └── _schema.ts        # Database schema management
    └── utils/
        ├── db-health.ts      # Health monitoring
        ├── with-db-retry.ts  # Exponential backoff retry
        ├── with-timeout.ts   # Timeout wrapper
        ├── pg-quote.ts       # SQL quoting
        └── sleep.ts          # Async sleep

tests/
├── jobs.test.ts              # Core functionality tests
├── db-resilience.test.ts     # Resilience tests
├── _tests-runner.ts          # Test harness
└── _pg.ts                    # PostgreSQL connection helper

example/
├── server.ts                 # Demo HTTP server
└── index.html                # Live monitor dashboard
```

## PUBLIC API

### Exports from mod.ts

```typescript
export { Jobs, type Job, type JobAttempt, type JobsOptions, JOB_STATUS, BACKOFF_STRATEGY, ATTEMPT_STATUS }
export { withDbRetry, type DbRetryOptions }
export { checkDbHealth, type DbHealthStatus, type DbHealthCheckOptions }
```

### Jobs Class Constructor Options

```typescript
interface JobsOptions {
    db: pg.Pool | pg.Client;              // Required: PostgreSQL connection
    tablePrefix?: string;                  // Table name prefix (default: "")
    jobHandler?: JobHandler;               // Global handler for all job types
    jobHandlers?: JobHandlersMap;          // Type-specific handlers map
    pollIntervalMs?: number;               // Polling interval (default: 1000)
    logger?: Logger;                       // Custom logger
    gracefulSigterm?: boolean;             // Listen to SIGTERM (default: true)
    dbRetry?: DbRetryOptions | boolean;    // Enable database retry
    dbHealthCheck?: DbHealthCheckOptions | boolean; // Enable health monitoring
}
```

### Jobs Class Methods

| Method | Signature | Description |
|--------|-----------|-------------|
| start | (processorsCount: number) => void | Start N concurrent workers |
| stop | () => Promise<void> | Graceful shutdown |
| create | (type, payload?, options?, onDone?) => Promise<Job> | Create a job |
| find | (uid, withAttempts?) => Promise<{job, attempts}> | Find job by UID |
| fetchAll | (status?, options?) => Promise<Job[]> | Fetch jobs with filtering |
| cleanup | () => Promise<void> | Mark expired jobs |
| healthPreview | (sinceMinutesAgo?) => Promise<Stats[]> | Get job statistics |
| setHandler | (type, handler) => void | Register handler for type |
| hasHandler | (type) => boolean | Check handler exists |
| resetHandlers | () => void | Clear all handlers |
| onDone | (type, callback) => unsubscribe | Subscribe to completions |
| onAttempt | (type, callback) => unsubscribe | Subscribe to attempts |
| onDoneFor | (uid, callback) => unsubscribe | Subscribe to specific job |
| onAttemptFor | (uid, callback) => unsubscribe | Subscribe to specific job attempts |
| getDbHealth | () => DbHealthStatus | null | Get last health status |
| checkDbHealth | () => Promise<DbHealthStatus> | Manual health check |

### Job Interface

```typescript
interface Job {
    id: number;
    uid: string;                          // UUID identifier
    type: string;                         // Job type/category
    payload: Record<string, any>;         // Input data
    result: null | Record<string, any>;   // Output data
    status: 'pending' | 'running' | 'completed' | 'failed' | 'expired';
    attempts: number;                     // Current attempt count
    max_attempts: number;                 // Max retries (default: 3)
    max_attempt_duration_ms: number;      // Timeout per attempt (0 = no limit)
    backoff_strategy: 'none' | 'exp';     // Retry backoff
    created_at: Date;
    updated_at: Date;
    started_at: Date;
    completed_at: Date;
    run_at: Date;                         // Scheduled execution time
}
```

### JobAttempt Interface

```typescript
interface JobAttempt {
    id: number;
    job_id: string;
    attempt_number: number;
    started_at: Date;
    completed_at: Date;
    status: 'success' | 'error';
    error_message: null | string;
    error_details: null | Record<string, any>;
}
```

### Constants

```typescript
const JOB_STATUS = { PENDING: 'pending', RUNNING: 'running', COMPLETED: 'completed', FAILED: 'failed', EXPIRED: 'expired' };
const BACKOFF_STRATEGY = { NONE: 'none', EXP: 'exp' };  // EXP = 2^attempts seconds
const ATTEMPT_STATUS = { SUCCESS: 'success', ERROR: 'error' };
```

## DATABASE SCHEMA

Two PostgreSQL tables are created with optional tablePrefix:

### {prefix}__job

| Column | Type | Description |
|--------|------|-------------|
| id | SERIAL | Primary key |
| uid | UUID | Unique identifier |
| type | VARCHAR(255) | Job type |
| payload | JSONB | Input data |
| result | JSONB | Output data |
| status | VARCHAR(20) | Job status |
| attempts | INTEGER | Current attempt count |
| max_attempts | INTEGER | Max retries |
| max_attempt_duration_ms | INTEGER | Timeout |
| backoff_strategy | VARCHAR(20) | Backoff type |
| created_at | TIMESTAMPTZ | Creation time |
| updated_at | TIMESTAMPTZ | Last update |
| run_at | TIMESTAMPTZ | Scheduled time |
| started_at | TIMESTAMPTZ | Execution start |
| completed_at | TIMESTAMPTZ | Completion time |

Indexes: status+run_at, uid, status

### {prefix}__job_attempt_log

| Column | Type | Description |
|--------|------|-------------|
| id | SERIAL | Primary key |
| job_id | INTEGER | FK to job |
| attempt_number | INTEGER | Attempt number |
| started_at | TIMESTAMPTZ | Start time |
| completed_at | TIMESTAMPTZ | End time |
| status | VARCHAR(20) | success/error |
| error_message | TEXT | Error message |
| error_details | JSONB | Error stack/details |

## KEY PATTERNS

### Atomic Job Claiming
Uses `FOR UPDATE SKIP LOCKED` to prevent race conditions:
```sql
UPDATE job SET status='running' WHERE id = (
    SELECT id FROM job WHERE status='pending' AND run_at <= NOW()
    ORDER BY run_at FOR UPDATE SKIP LOCKED LIMIT 1
) RETURNING *
```

### Job Execution Flow
1. Job created (status: pending)
2. Worker claims job atomically (status: running)
3. Handler executed with optional timeout
4. Success: status=completed, result stored
5. Failure: if attempts < max_attempts: status=pending + backoff delay, else status=failed

### Exponential Backoff
Delay = 2^attempts seconds (e.g., 2s, 4s, 8s, 16s, ...)

### Database Resilience
Retryable errors: ECONNREFUSED, ECONNRESET, ETIMEDOUT, ENOTFOUND, 57P03, 08006, 08003, 08000

## DEPENDENCIES

| Package | Purpose |
|---------|---------|
| pg | PostgreSQL client |
| @marianmeres/clog | Logging |
| @marianmeres/pubsub | Event system |
| @marianmeres/data-to-sql-params | SQL params |
| @marianmeres/parse-boolean | Boolean parsing |

## BUILD & DEVELOPMENT

```bash
deno task test           # Run tests
deno task example        # Run demo server
deno task npm:build      # Build for npm
deno task npm:publish    # Build and publish to npm
```

Test database: Configure via TEST_PG_* environment variables

## COMMON USAGE PATTERNS

### Basic Setup
```typescript
const jobs = new Jobs({
    db: pgPool,
    jobHandler: async (job) => {
        // process job, throw on error
        return { result: 'data' };
    }
});
await jobs.start(2);  // 2 workers
```

### Type-Specific Handlers
```typescript
const jobs = new Jobs({
    db: pgPool,
    jobHandlers: {
        'email': async (job) => sendEmail(job.payload),
        'process': async (job) => process(job.payload)
    }
});
```

### Job with Retry Configuration
```typescript
await jobs.create('task', payload, {
    max_attempts: 5,
    backoff_strategy: 'exp',
    max_attempt_duration_ms: 30000,
    run_at: new Date(Date.now() + 60000)  // 1 min delay
});
```

### Event Subscriptions
```typescript
jobs.onDone('type', (job) => console.log(job.status));
jobs.onAttempt('type', (job) => console.log('attempt', job.attempts));
const unsub = jobs.onDoneFor(uid, (job) => { /* specific job */ });
```

### Resilience Configuration
```typescript
const jobs = new Jobs({
    db: pgPool,
    dbRetry: { maxRetries: 5, initialDelayMs: 200, maxDelayMs: 10000 },
    dbHealthCheck: {
        intervalMs: 30000,
        onUnhealthy: (s) => alert(s.error),
        onHealthy: (s) => console.log('recovered')
    }
});
```

## FILE MODIFICATION GUIDANCE

When modifying this codebase:

1. **Source files**: Edit in `src/steve/` - private job operations are prefixed with `_`
2. **Public API changes**: Update `src/mod.ts` exports
3. **Schema changes**: Update `src/steve/job/_schema.ts`
4. **Tests**: Add to `tests/jobs.test.ts` or create new test file
5. **Version bump**: Update in `deno.json`
6. **Documentation**: Update `README.md` and this `llm.txt`

## INTERNAL CONVENTIONS

- Private class fields use `#` prefix
- Private module functions use `_` prefix
- JobContext object passed internally to job operations
- Lazy schema initialization via `#initializeOnce()`
- Error logging has spam prevention (max consecutive errors)
- All database operations use parameterized queries ($1, $2, ...)
